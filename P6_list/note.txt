对于链表题：
（1）对于笔试，不用在乎空间复杂度，一切为了时间复杂度
（2）对于面试， 时间复杂度放第一位，但要找出空间最省方法

一.判断单链表是不是回文单链表
(1) 压进栈，看看栈弹出时是否与原本相同
(2) 将链表分为两半，后半部分压进栈，看栈弹出是否与前半完全相等，栈弹空时说明是回文（省一半空间）使用快慢指针，快指针一次两步，慢指针一次一步
快指针到终点说明慢指针到一半

二.给定两个可能有环也可能无环的单链表，头节点为head1和head2，如果两个链表相交，返回相交的第一个节点，否则返回null。
    （要求：）如果两个链表的长度之和为N，时间复杂度请达到O（N），额外空间复杂度达到O（1）
1）使用hashset来判断是否有环。遍历链表，将每一个未出现的节点放入，若出现一个节点已存在，那该节点就是入环的第一节点
2）使用快慢指针来判断是否有环。如果快指针最终指向null，则无环，否则快慢指针必定相遇，当两个指针相遇时，快指针回到链表开头，慢指针不动，两个指针
一次走一步，则两个指针一定在入环第一节点再次相遇！！！

解法：将head1和head2分别调用getLoopNode函数，得到入环节点loop1和loop2

//例子：noloop函数
1. loop1 == null, loop2 == null,  若两个单链表相交，则从相交节点开始，到链表末尾都共有。遍历第一个链表，记录末尾节点end1和长度length1，
遍历第二个链表，记录末节点end2和长度length2.判断end1和end2地址是否相同，如果不同，则无交点，如果相同，建立两个指针n1和n2， 比较leangth1和
length2， 哪个长哪个指针先走|length1-length2|步，再同时开始走，两个指针相同就是入环第一节点 

2. loop1 和 loop2 一个为空一个不为空， 不存在！！！

3. loop1 和 loop2 都有环
3.1 两个链表各自独立， loop1 继续往下走，在遇到自己之前，如果loop1 ！= loop2，返回null

3.2 共用环，入环节点是同一个点（loop1 == loop2），等同于两个无环节点的相交问题，将loop1 视为终止节点，计算两个链表的长度，并使用一个指针先走
差值步数，之后两个指针同时走，两指针相等时为相交节点

3.3 共用环，入环节点不为一个(loop1 != loop2)，loop1 继续往下走，在遇到自己之前，如果loop1 == loop2， 返回loop1或者loop2都行，
两个节点都可以说是第一个相交节点