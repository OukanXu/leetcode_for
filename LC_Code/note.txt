2. Add Two Numbers
两个链表相加，链表为数字的逆序表示

解： 链表相加，要多考虑进位


3. Longest Substring Without Repeating Characters
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度

解： 双指针，考虑出现重复字符是left的位置


5. Longest Palindromic Substring
给你一个字符串 s，找到 s 中最长的回文子串

解： 考虑回文的两种情况，奇数偶数，最优解manacher，O(N),常规算法O(N^2)


6. Zigzag Conversion
将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列

解： 建立多个StringBuilder，利用flag来考虑转折时的问题，最后合并StringBuilder


7. Reverse Integer
给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果

解： 要考虑Integer.MAX_VALUE 和 Integer.MIN_VALUE,防止越界

8. String to Integer (atoi)
实现atoi算法

解： 考虑正数和负数越界的情况


11. Container With Most Water
给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量

解： 双指针


12. Integer to Roman
给定一个数字，转换成罗马数字

解： 表+贪心，每次尽量考虑最大的


13. Roman to Integer
罗马文转数字

解： 1.替换+打表，将特殊情况全都替换，并且建立表   2. 根据罗马文的规则，如果一个数字比前一个小，那么应该减去，否则就加上（更快），也要打表


15. 3Sum
三数之和

解： 先确定一个点，再考虑two sum


16. 3Sum Closest
三数和与target差值最小

解： 类似三数和，比较的时候比较差值


17. Letter Combinations of a Phone Number
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

解： hashmap + dfs+ backtrace


18. 4Sum
四数之和问题

解： 类似三数和，确定两个外围数之和再确定里面两个，要注意int的范围问题


19. Remove Nth Node From End of List
给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点

解： 双指针


20. Valid Parentheses
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效

解： 栈+哈希表

21. Merge Two Sorted Lists
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的

解： 迭代/递归



22. Generate Parentheses
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合

解： dfs/dp

24. Swap Nodes in Pairs
给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题

解： 递归/迭代



26. Remove Duplicates from Sorted Array
原地更改数组，保留前K个不重复项

解： 双指针，记录每个不重复的位置


27. Remove Element
原地删除数组中等于val的值，不改变数组长度

解： 双指针



28. Find the Index of the First Occurrence in a String
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1

解： KMP算法运用



29. Divide Two Integers
两数相除，不能用乘除和取余


解： 用快速幂，每次*2


31. Next Permutation
给一个整数数组，返回下一个字典序

解： 找出从后往前的峰谷，再找出第一个大于峰谷的数，交换，然后排序


33. Search in Rotated Sorted Array
旋转数组的二分查找

解： 先确定left和mid的位置关系，再考虑target


34. Find First and Last Position of Element in Sorted Array
给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]

解： 二分查找

35. Search Insert Position
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置

解： 二分查找


36. Valid Sudoku
验证数独是否有效

解： 哈希表， 要看在哪个小方块里面  j/3 + (i/3)*3


38. Count and Say
给定一个正整数 n ，输出外观数列的第 n 项。

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

你可以将其视作是由递归公式定义的数字字符串序列

解： 递归，每次更新字符串，用for来模拟递归




39. Combination Sum
给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，
找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合

解： 递归+回溯


40. Combination Sum II
给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用 一次

解： 递归+回溯， 同时要判断同一层递归是否有重复（优化： 可以记录每个数字出现的次数，讨论每次使用的情况，如果次数用完，就得使用下一个数字）



45. Jump Game II
给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。

每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处

解： dp+贪心 从数组头开始，找到下一步能跑最远的下标 next，不断更新 


46. Permutations
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案

解： 递归+回溯  找个东西记住已经访问过的数字（数组或者动态数组） visited数组更快



47. Permutations II
给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列

解： 递归+回溯 找个东西记住已经访问过的数字（数组或者动态数组） 对于同一递归层下，相同的元素要跳过  visited数组更快

49. Group Anagrams
给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。

字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次

解： hash+sort


53. Maximum Subarray
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和

解： dp


54. Spiral Matrix
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素

解： 模拟， 用四个边界来判断是否已经输出所有， 对于每一圈的最后两条边，要多一重验证，判断是否已经结束
[[1,2,3,4],[5,6,7,8],[9,10,11,12]] -> [1,2,3,4,8,12,11,10,9,5,6,7]


55. Jump Game
给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标

解： 贪心，维护一个最远距离，判断最远能否超出数组长度


56. Merge Intervals
以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。
请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间

解： 需要变更数组长度，所有ArrayList， 每次和ArrayList最末尾区间进行判断，是否合并或者整个加入。 需要对数组先排序


57. Insert Interval
给你一个 无重叠的 ，按照区间起始端点排序的区间列表。
在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间

解： ArrayList动态存储，分清边界条件，更新 新区间


58. Length of Last Word
给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。

单词 是指仅由字母组成、不包含任何空格字符的最大子字符串

解： 后往前遍历，遇到空格跳过，遇到第一个非空格开始统计，再次遇到空格停止


59. Spiral Matrix II
给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix

解： 模拟，半圈之后判断是否能进行剩下的半圈


61. Rotate List
给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置

解： 模拟旋转。找出从哪里断开，双指针


62. Unique Paths
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径

解： 经典dp


63. Unique Paths II
带障碍的Unique Path。

解： 经典dp， 考虑障碍的情况



64. Minimum Path Sum
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步

解： 经典二维dp


66. Plus One
给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头

解： 数组+1， 要考虑进位以及数组长度是否改变


67. Add Binary
给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和

解： 配平字符串，StringBuilder 更快


69. Sqrt(x)
给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5

解： 二分查找


70. Climbing Stairs
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢

解： dp


73. Set Matrix Zeroes
给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法

解： 1.记录哪一行哪一列出现0，然后再次遍历的时候置零  空间O(m+n)
     2.利用第一行、第一列来当标记，遍历时从（1,1）开始，用两个标记记录第一行、第一列有没有0（空间O（1））


74. Search a 2D Matrix
编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数

解： 两次二分查找，第一次找哪一行，第二次找哪一列


75. Sort Colors
将数组中的0,1,2排序

解： 双指针，一个p0，一个p1， 当index指向0时，swap(index,p0),并且如果p0 > p1, swap(index,p1),   p0++,p1++
当index指向1时，swap(index,p1), p1++

77. Combinations
给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
你可以按 任何顺序 返回答案

解： dfs，要考虑可以搜索的上界来剪枝   最大上界为 n-(k-temp.size())+1


78. Subsets
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集

解： 对于每一个元素，考虑 要 和 不要 两种情况


79. Word Search
给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用

解： dfs + 记忆化搜索

80. Remove Duplicates from Sorted Array II
给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成

解： 双指针，左指针表示要处理的下一个元素，右指针表示数组中已经处理的元素，右指针要与 左指针-2 对比


81. Search in Rotated Sorted Array II
螺旋数组，但是有重复值

解： 双指针二分查找， 注意当left元素和mid元素相等时，分不清哪边有序，所以要left++，排除干扰


82. Remove Duplicates from Sorted List II
给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表

解： 双指针遍历， 遇到相同元素时，记录下元素的值，然后一直向后遍历等于这个值的


83. Remove Duplicates from Sorted List (easy)
给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表

解： 双指针，移除重复数据


86. Partition List (medium)
给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。
你应当 保留 两个分区中每个节点的初始相对位置

解： 双dummy node， 双指针遍历链表，根据val大小决定哪个指针链接


88. Merge Sorted Array (easy)
给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列

解： 双指针，从num1 后部开始插入元素


90. Subsets II
给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列

解： dfs， 设置一个已经使用的参数pre，如果前一个数没使用，并且当前数与前一个数相同，直接跳过


91. Decode Ways
一条包含字母 A-Z 的消息通过以下映射进行了 编码

解： dp，考虑当前字符，和当前字符与前一字符的情况


92. Reverse Linked List II (medium)
给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表

解： 先找到两个端点，分别为left前、right后，断开两边，将中间翻转，再连回来
    还可以用一次遍历，通过复用cur，pre，next三个指针，完成翻转

94. Binary Tree Inorder Traversal (easy)
给定一个二叉树的根节点 root ，返回 它的 中序 遍历

解： 先左孩子，然后处理根节点，再右孩子


95. Unique Binary Search Trees II (medium)
给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案

解： 遍历 1 - n 的所有节点作为根节点，递归左子树 1 - i-1， 右子树 i+1 - n， 对于所有的左子树分别匹配对应的右子树，
递归出口为 start > end 时，加入null节点


96. Unique Binary Search Trees (medium)
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数

解： 其余同95题， 利用哈希表来减少计算时间


97. Interleaving String (medium)
给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的

解： 二维dp，双指针p1、p2 对s1、s2 进行遍历， 
    定义f(i,j)表示 s1的前i + s2的前j 能不能凑齐 s3 的前 i+j， f(i,j) 取决于 f(i-1,j)、f(i,j-1), 以及
    s1(i) == s3(i+j-1) or s2(j) == s3(i+j-1)
    优化： 一维dp


98. Validate Binary Search Tree
验证一棵树是否为搜索二叉树

解： 1. 利用搜索二叉树性质，传递三个参数 isBST min max来验证
     2. 利用搜索二叉树中序遍历成升序的性质来判断

99. Recover Binary Search Tree
给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树

解：一个BST经过中序遍历之后应该为升序排列，所以先中序遍历树，如果结果为升序，返回，否则记录两个错误的节点，调换节点值


100. Same Tree
判断两颗树是否相同

解： dfs，判断两个节点的情况


101. Symmetric Tree
给你一个二叉树的根节点 root ， 检查它是否轴对称

解： dfs， 两个节点判断

102. Binary Tree Level Order Traversal
给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点)

解： 使用queue，一层层遍历

103. Binary Tree Zigzag Level Order Traversal
给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行)

解： deque， pollLast对应addFirst， pollFirst对应addLast


104. Maximum Depth of Binary Tree
给定一个二叉树，找出其最大深度

解： dfs，返回左孩子和右孩子的最大值+1


105. Construct Binary Tree from Preorder and Inorder Traversal
给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点

解： 利用hashmap存储inorder的value和index， dfs， 分割preorder来确定左右子树

106. Construct Binary Tree from Inorder and Postorder Traversal
给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树

解： 同105

107. Binary Tree Level Order Traversal II
给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历

解： 同102，ArrayList.add(index,element)


108. Convert Sorted Array to Binary Search Tree
给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树

解： 类似105、106，通过确定mid来确定左右子树


109. Convert Sorted List to Binary Search Tree
给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树

解： 同108 
    法一： 抽象ArrayList，建立树
    法二： 直接在listNode上找中点，建立树
















































306. Additive Number
一. 需要遍历判断第一个数和第二个数 -> 只需要判断第二个数的位置，第一个数一定是开头到第二个数之前，要判断如果开头为0，那么只能是0
二. 计算两个数的和，判断第三个数（从字符串中取出来）是否等于这两个数的和
是：将第二个数变为第一个数，第三个数变为第二个数，继续遍历，直到到达字符串结尾
否：跳出循环，在上一层继续遍历第二个数
三. 为了防止数字越界，使用字符串进行加法运算


307.Range Sum Query - Mutable

方法一：使用树状数组+前缀和
一. https://leetcode.cn/problems/range-sum-query-mutable/solution/-by-hu-ge-8-t4rn/
前缀和数组保存前缀和，s8 = n1+...+n8  s4 = n1+...n4  s2 = n1+n2  s1 = n1  s6 = n5+n6 利用位运算 j&(-j)获取j的最后一位1，
preSum(7) = s7(n7)+s6(n5+n6)+s4(n1+...n4)


309.Best Time to Buy and Sell Stock with Cooldown
需要考虑三种情况：
一. 当前持有股票，那么当前的状态有两种可能，之前持有股票，或者之前处于冷冻期结束
二. 当前不持有股票，且当前在冷冻期。那么说明前一天持有股票并卖出了
三. 当前不持有股票，且不在冷冻期。那么说明前一天在冷冻期，或者前一天也不持有股票且不在冷冻期


310.Minimum Height Trees
基于拓扑排序以及bfs来处理
先根据二维数组建立入度表，因为这里是无向边，所以不用区分入度与出度
将所有度数为一的点进入队列，分别弹出这些点，并且根据哈希表变更与其相连的其他点的入度，将变更后度数为1的点加入队列
最后的答案为最后一批加入队列的点


313.Super Ugly Number
使用动态规划和多指针来处理
建立多指针数组pointers，建立乘积数组nums来储存乘积。
遍历nums，找到最小值，放入dp中，并使得对应的pointer+1，更新nums（注意，因为要使得nums都为Ugly Number，所以不能直接用pointer * primes，
要利用dp找到当前的pointer所对应的值，然后再乘nums）


314.Binary Tree Vertical Order Traversal
使用bfs来处理
在将节点加入队列时，应该同时保存节点的列位置
TreeMap可以自动维护key从小到大

316. Remove Duplicate Letters
问题：给定一个字符串，返回一个字典序最小的字符串，并且字符串中每个字母出现一次

使用单调栈来进行处理
解法一：
统计原串中每个字母出现的次数
遍历字符串，对每个字符判断是否小于栈顶元素，如果是并且栈顶元素在之后还存在，弹出栈顶，重复以上操作，最后将该字符入栈，更新次数

解法二：(faster , use array)
统计原串中每个字母出现的最后位置
其余同上


318. Maximum Product of Word Lengths
问题：给一个字符串数组，求两个字符串的乘积，并且这两个字符串没有公共字符
使用位运算来处理
解法：使用26个位来表示哪些字母出现，若两个字符串有重复，则他俩的与运算一定不为0



319. Bulb Switcher
初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭第二个。
第三轮，你每三个灯泡就切换第三个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换第 i 个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。
找出并返回 n 轮后有多少个亮着的灯泡

解：一个编号为 x 的灯泡经过 n 轮后处于打开状态的充要条件为「该灯泡被切换状态次数为奇数次」-> 求1--> n中有几个完全平方数，根据数论推理，有根号n个


320. Generalized Abbreviation
问题： 给定一个字符串，返回所有的字符串缩写

解法：使用dfs暴力遍历，每个字符有两种状态，压缩或者不压缩，总共有2**n个答案

322. Coin Change
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的

解法一：暴力递归：从0到amount递归，找出所有可能凑成amount的方法，找到最小值（超时）
解法二： 记忆化搜索： 从amount到0递归，对于已经计算过的amount保留其最小值，最终得出amount的最小值
解法三： 动态规划： 与记忆化搜索类似，不过用数组来处理，节省空间和时间



323. Number of Connected Components in an Undirected Graph
你有一个包含 n 个节点的图。给定一个整数 n 和一个数组 edges ，其中 edges[i] = [ai, bi] 表示图中 ai 和 bi 之间有一条边。
返回 图中已连接分量的数目。

解法：dfs bfs 并查集

dfs：先统计每个点的邻居点，设置一个visited数组，每次来到一个新的节点，如果未访问，count++，深度遍历与其所有相邻的节点（就是遍历该图上的所有节点）
（与岛屿数量问题基本一样）

324. Wiggle Sort II
给你一个整数数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。

你可以假设所有输入数组都可以得到满足题目要求的结果。

解法： 先将数组复制并排序，使用双指针，left指向克隆数组的中部，right指向末尾，遍历原数组，依次填充left、right



325. Maximum Size Subarray Sum Equals k
给定一个数组 nums 和一个目标值 k，找到和等于 k 的最长连续子数组长度。如果不存在任意一个符合要求的子数组，则返回 0。

解法：使用前缀和+哈希表处理，类似于求两数之和为target，这个为两数之差为target


328. Odd Even Linked List
问题：给定一个链表，将奇数位与偶数位拆分再合并，生成新链表

解：使用两个dummy，将分别将链表奇数位和偶数位串起来，分割奇偶之间的next


333. Largest BST Subtree
问题：经典树状dp问题，求BST的最大个数

解法：向左右子树要最大值和最小值，并且要size，通过size来判断是否为BST，如果不是，size = -1

331. Verify Preorder Serialization of a Binary Tree
问题：判断一个前序队列是否能组成二叉树

使用‘槽’这个概念来处理。初始槽为1，读取一个数字，槽-1+2，读取一个null，槽-1，最后判断槽是否为0，如果是，true


334. Increasing Triplet Subsequence
给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。
如果存在这样的三元组下标 (i, j, k) 且满足 i < j < k ，使得 nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 

解：1：遍历数组，分别求出i位置左侧最小和右侧最大，再遍历原数组判断左右大小
    2： 贪心算法，维护一个空间大小为2的数组，分别代表长度的1、2的序列的末尾数字，遍历数组，碰到比1、2小的就更新，如果出现比1、2大的，返回true
    3： 贪心： 维护两个变量first、second，其余同上


337. House Robber III
小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。
除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。
给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。

解：经典树状DP问题，但是在传递的过程中，要注意，如果父节点不偷，那么子节点可以偷也可以不偷，不一定是隔行投最划算


340. Longest Substring with At Most K Distinct Characters
给你一个字符串 s 和一个整数 k ，请你找出 至多 包含 k 个 不同 字符的最长子串，并返回该子串的长度

解法一：滑动窗口+哈希表，哈希表每次删除index最小的字母
解法二： 滑动窗口+有序哈希表（可以实现每次查找index最小的时间为O（1））


341. Flatten Nested List Iterator

解法一：将nestList展开
解法二：直接在原来的nestList中遍历迭代（方法更好，但是时间较长）


342. Power of Four
问题：判断一个数是否为4的幂

解法：这个数要大于0，并且其二进制表示中只能出现1个1，并且其mod 3 == 1



343. Integer Break
给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。
返回 你可以获得的最大乘积

解法：根据求导可得，n只能以2、3构成
最优： 3 。把数字 n 可能拆为多个因子 3 ，余数可能为 0,1,2 三种情况。
次优： 2 。若余数为 2 ；则保留，不再拆为 1+1 。
最差： 1 。若余数为 1 ；则应把一份 3 + 1 替换为 2 + 2，因为 2 * 2 > 3*1


347. Top K Frequent Elements
给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素

解：使用优先队列来解决
先遍历数组，并统计每个数字出现的次数，加入哈希表，用优先队列建立最小堆，将小于堆顶的元素放弃，大于堆顶的就抛弃堆顶并加入



355. Design Twitter

难点：合并k个有序序列
使用priorityQueue来处理


356. Line Reflection
在一个二维平面空间中，给你 n 个点的坐标。问，是否能找出一条平行于 y 轴的直线，让这些点关于这条直线成镜像排布？
注意：题目数据中可能有重复的点
解：使用排序+双指针
或者使用set来处理
重点：找出中轴线


357. Count Numbers with Unique Digits
给你一个整数 n ，统计并返回各位数字都不同的数字 x 的个数，其中 0 <= x < 10**n

想必大家都对高中数学知识忘得差不多了。这题可以用动态规划解：

n=0，数字有{0}1个。

n=1，数字有{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}10个。

n=2，数字包括两部分之和，一部分为n=1的所有10个答案，另一部分为长度为2的新增数字。长度为2的新增数字可以在n=1的所有9个数字基础上进行拼接（0不能算）。例如：

从n=1的数字列表{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}中随便取出一个除0以外的数字（因为0不能作为起始数字！），我们取2好了。通过在2的尾巴处拼接一位数字可以得到新的合法数字有：

{20， 21，23，24，25，26，27，28，29}，

可以看到，除了不能在尾巴处拼接一个2（两个连续的2就非法了！），0-9种一共有9个数字可以拿来拼接在尾巴处。新增答案为9个。同理，对于n=1数字列表{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}中的其他任意非0数也可以进行拼接操作，一共可以新增9*9个答案。

最终，n=2的合法数字，n=1时的答案 + 长度为2的数字个数（9*9个）= 10 + 81 = 91。

n=3时同理，只不过此时可以用拼接的数字减少为了8个，此时答案为10 + 9 * 9 + 9 * 9 * 8 = 739。

n=4时同理，只不过此时可以用拼接的数字减少为了7个，此时答案为10 + 9 * 9 + 9 * 9 * 8 + 9 * 9 * 8 * 7 = 5275。

通过归纳不难得到，假设 dp[i] 即 n = i时的答案，则动态转移方程为：

dp[i] = dp[i-1] + (dp[i-1] - dp[i-2])*(10-(i-1))

转移的初始条件为

dp[0] = 1

dp[1] = 10


361. Bomb Enemy
给你一个大小为 m x n 的矩阵 grid ，其中每个单元格都放置有一个字符：

'W' 表示一堵墙
'E' 表示一个敌人
'0'（数字 0）表示一个空位
返回你使用 一颗炸弹 可以击杀的最大敌人数目。你只能把炸弹放在一个空位里。

由于炸弹的威力不足以穿透墙体，炸弹只能击杀同一行和同一列没被墙体挡住的敌人

解法：
1.暴力破解，对于每个为‘0’ 的空格，遍历上下左右
2.dp 建立一个二维数组，统计每一个位置能找到的敌人，对一个位置，分别从左到右，从右到左，从上到下，从下到上四次扫描


362. Design Hit Counter
设计一个敲击计数器，使它可以统计在过去 5 分钟内被敲击次数。（即过去 300 秒）

您的系统应该接受一个时间戳参数 timestamp (单位为 秒 )，并且您可以假定对系统的调用是按时间顺序进行的(即 timestamp 是单调递增的)。几次撞击可能同时发生。

实现 HitCounter 类:

HitCounter() 初始化命中计数器系统。
void hit(int timestamp) 记录在 timestamp ( 单位为秒 )发生的一次命中。在同一个 timestamp 中可能会出现几个点击。
int getHits(int timestamp) 返回 timestamp 在过去 5 分钟内(即过去 300 秒)的命中次数

解法：
简单：用队列储存timestamp，用count来统计，每次要判断队列是否在新的timestamp-300之内，不是就弹出


364. Nested List Weight Sum II
返回一个列表的加权和  权重 = MaxDeep - deep + 1

解法一： dfs整个列表，获取maxDeep， 再dfs列表，求sum  两遍dfs
解法二： dfs整个列表，记录当前深度以及在该深度下的元素和，然后计算sum   一遍dfs


365. Water and Jug Problem
整数中的裴蜀定理
对任意两个整数a、b，设d是它们的最大公约数。那么关于未知数x和y的线性丢番图方程（称为 裴蜀等式 ）：
ax + by = m
有整数解（x,y）当且仅当m是d的倍数
最大公约数用辗转相除法求得


366. Find Leaves of Binary Tree
给你一棵二叉树，请按以下要求的顺序收集它的全部节点：

依次从左到右，每次收集并删除所有的叶子节点
重复如上过程直到整棵树为空

解： 其实就是对节点计算从叶子到根的深度，相同深度的组合一起



368. Largest Divisible Subset(最大整除数的集合)
给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足：
answer[i] % answer[j] == 0 ，或
answer[j] % answer[i] == 0
如果存在多个有效解子集，返回其中任何一个均可

解： sort + dp 


369. Plus One Linked List
给定一个用链表表示的非负整数， 然后将这个整数 再加上 1 。

这些数字的存储是这样的：最高位有效的数字位于链表的首位 head

解： 翻转链表再加1，注意要判断需不需要多加一个节点
或者 找到最后一位不为9的节点，将后面的都归0，该节点+1


370. Range Addition
假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，你将会被给出 k​​​​​​​ 个更新的操作。

其中，每个操作会被表示为一个三元组：[startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]（包括 startIndex 和 endIndex）增加 inc。

请你返回 k 次操作后的数组


解： 使用前缀和。 对于startIndex， + inc  对于endIndex+1， -inc。 就是处理数组，使其明白与前一个数的差值为多少，最后对整个数组求前缀和


371. Sum of Two Integers
不是用+ -来计算两数相加

解： 使用位运算来处理
用异或来求得两个数不产生进位是的答案
用与来求得哪一位产生进位，并且左移一位

372. Super Pow
你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出

解： (a⋅b) mod m=[(a mod m)⋅(b mod m)] mod m
利用底数a，对数组中的每一位b[i]进行计算取模，然后每次对a计算 a的10次幂取模


373. Find K Pairs with Smallest Sums
给定两个升序数组，找出k个和最小的对

解： 使用priorityQueue来处理。先将num1的所有和num2的第一个数组成的index对加入队列，每次取出一个，然后将num2的index+1的那一对加进来


375. Guess Number Higher or Lower II
我们正在玩一个猜数游戏，游戏规则如下：

我从 1 到 n 之间选择一个数字。
你来猜我选了哪个数字。
如果你猜到正确的数字，就会 赢得游戏 。
如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。
每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。
给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字

解： 类似于抽卡牌游戏，需要找到pick数字为x，1<=x<=n 时的最大代价，然后在所有的x中找到最小代价


376. Wiggle Subsequence
求一个数组中摆动排序最大长度

解： dp 借用两个参数up down， 分别表示末尾升序/降序的摆动排序的长度

377. Combination Sum IV
给定一个target 和一个数组nums，问用数组中的元素凑target，有几种凑法

解： dp    dfs（超时）


378. Kth Smallest Element in a Sorted Matrix
给定一个每行每列都升序的矩阵，求第k个数

解：1. 多路归并（考虑了每行升序） 2. 区域二分查找（考虑了每行每列升序）


380. Insert Delete GetRandom O(1)
在O(1)时间内实现 插入、删除、获取随机元素

解： 哈希表+不定长数组

382. Linked List Random Node
给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样

解： 数组模拟


383. Ransom Note
给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

如果可以，返回 true ；否则返回 false 。

magazine 中的每个字符只能在 ransomNote 中使用一次

解： 哈希表/ 数组模拟哈希表


384. Shuffle an Array
给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 等可能 的

解法： 洗牌算法， 对于每个下标i，将i与i之后的随机下标互换

386. Lexicographical Numbers
给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。

你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法

解： 能*10就*， 不能就/10,算好步数

387. First Unique Character in a String
给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1

解： 哈希表或数组模拟哈希表

389. Find the Difference
给定两个字符串 s 和 t ，它们只包含小写字母。

字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。

请找出在 t 中被添加的字母

解： 异或，数组模拟，哈希