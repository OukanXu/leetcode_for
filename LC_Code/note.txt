2. Add Two Numbers
两个链表相加，链表为数字的逆序表示

解： 链表相加，要多考虑进位


3. Longest Substring Without Repeating Characters
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度

解： 双指针，考虑出现重复字符是left的位置


5. Longest Palindromic Substring
给你一个字符串 s，找到 s 中最长的回文子串

解： 考虑回文的两种情况，奇数偶数，最优解manacher，O(N),常规算法O(N^2)


6. Zigzag Conversion
将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列

解： 建立多个StringBuilder，利用flag来考虑转折时的问题，最后合并StringBuilder


7. Reverse Integer
给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果

解： 要考虑Integer.MAX_VALUE 和 Integer.MIN_VALUE,防止越界

8. String to Integer (atoi)
实现atoi算法

解： 考虑正数和负数越界的情况


11. Container With Most Water
给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量

解： 双指针


12. Integer to Roman
给定一个数字，转换成罗马数字

解： 表+贪心，每次尽量考虑最大的


13. Roman to Integer
罗马文转数字

解： 1.替换+打表，将特殊情况全都替换，并且建立表   2. 根据罗马文的规则，如果一个数字比前一个小，那么应该减去，否则就加上（更快），也要打表


15. 3Sum
三数之和

解： 先确定一个点，再考虑two sum


16. 3Sum Closest
三数和与target差值最小

解： 类似三数和，比较的时候比较差值


17. Letter Combinations of a Phone Number
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

解： hashmap + dfs+ backtrace


18. 4Sum
四数之和问题

解： 类似三数和，确定两个外围数之和再确定里面两个，要注意int的范围问题


19. Remove Nth Node From End of List
给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点

解： 双指针


20. Valid Parentheses
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效

解： 栈+哈希表

21. Merge Two Sorted Lists
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的

解： 迭代/递归



22. Generate Parentheses
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合

解： dfs/dp

24. Swap Nodes in Pairs
给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题

解： 递归/迭代



26. Remove Duplicates from Sorted Array
原地更改数组，保留前K个不重复项

解： 双指针，记录每个不重复的位置


27. Remove Element
原地删除数组中等于val的值，不改变数组长度

解： 双指针



28. Find the Index of the First Occurrence in a String
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1

解： KMP算法运用



29. Divide Two Integers
两数相除，不能用乘除和取余


解： 用快速幂，每次*2


31. Next Permutation
给一个整数数组，返回下一个字典序

解： 找出从后往前的峰谷，再找出第一个大于峰谷的数，交换，然后排序


33. Search in Rotated Sorted Array
旋转数组的二分查找

解： 先确定left和mid的位置关系，再考虑target


34. Find First and Last Position of Element in Sorted Array
给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]

解： 二分查找

35. Search Insert Position
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置

解： 二分查找


36. Valid Sudoku
验证数独是否有效

解： 哈希表， 要看在哪个小方块里面  j/3 + (i/3)*3


38. Count and Say
给定一个正整数 n ，输出外观数列的第 n 项。

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

你可以将其视作是由递归公式定义的数字字符串序列

解： 递归，每次更新字符串，用for来模拟递归




39. Combination Sum
给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，
找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合

解： 递归+回溯


40. Combination Sum II
给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用 一次

解： 递归+回溯， 同时要判断同一层递归是否有重复（优化： 可以记录每个数字出现的次数，讨论每次使用的情况，如果次数用完，就得使用下一个数字）



45. Jump Game II
给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。

每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处

解： dp+贪心 从数组头开始，找到下一步能跑最远的下标 next，不断更新 


46. Permutations
给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案

解： 递归+回溯  找个东西记住已经访问过的数字（数组或者动态数组） visited数组更快



47. Permutations II
给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列

解： 递归+回溯 找个东西记住已经访问过的数字（数组或者动态数组） 对于同一递归层下，相同的元素要跳过  visited数组更快




306. Additive Number
一. 需要遍历判断第一个数和第二个数 -> 只需要判断第二个数的位置，第一个数一定是开头到第二个数之前，要判断如果开头为0，那么只能是0
二. 计算两个数的和，判断第三个数（从字符串中取出来）是否等于这两个数的和
是：将第二个数变为第一个数，第三个数变为第二个数，继续遍历，直到到达字符串结尾
否：跳出循环，在上一层继续遍历第二个数
三. 为了防止数字越界，使用字符串进行加法运算


307.Range Sum Query - Mutable

方法一：使用树状数组+前缀和
一. https://leetcode.cn/problems/range-sum-query-mutable/solution/-by-hu-ge-8-t4rn/
前缀和数组保存前缀和，s8 = n1+...+n8  s4 = n1+...n4  s2 = n1+n2  s1 = n1  s6 = n5+n6 利用位运算 j&(-j)获取j的最后一位1，
preSum(7) = s7(n7)+s6(n5+n6)+s4(n1+...n4)


309.Best Time to Buy and Sell Stock with Cooldown
需要考虑三种情况：
一. 当前持有股票，那么当前的状态有两种可能，之前持有股票，或者之前处于冷冻期结束
二. 当前不持有股票，且当前在冷冻期。那么说明前一天持有股票并卖出了
三. 当前不持有股票，且不在冷冻期。那么说明前一天在冷冻期，或者前一天也不持有股票且不在冷冻期


310.Minimum Height Trees
基于拓扑排序以及bfs来处理
先根据二维数组建立入度表，因为这里是无向边，所以不用区分入度与出度
将所有度数为一的点进入队列，分别弹出这些点，并且根据哈希表变更与其相连的其他点的入度，将变更后度数为1的点加入队列
最后的答案为最后一批加入队列的点


313.Super Ugly Number
使用动态规划和多指针来处理
建立多指针数组pointers，建立乘积数组nums来储存乘积。
遍历nums，找到最小值，放入dp中，并使得对应的pointer+1，更新nums（注意，因为要使得nums都为Ugly Number，所以不能直接用pointer * primes，
要利用dp找到当前的pointer所对应的值，然后再乘nums）


314.Binary Tree Vertical Order Traversal
使用bfs来处理
在将节点加入队列时，应该同时保存节点的列位置
TreeMap可以自动维护key从小到大

316. Remove Duplicate Letters
问题：给定一个字符串，返回一个字典序最小的字符串，并且字符串中每个字母出现一次

使用单调栈来进行处理
解法一：
统计原串中每个字母出现的次数
遍历字符串，对每个字符判断是否小于栈顶元素，如果是并且栈顶元素在之后还存在，弹出栈顶，重复以上操作，最后将该字符入栈，更新次数

解法二：(faster , use array)
统计原串中每个字母出现的最后位置
其余同上


318. Maximum Product of Word Lengths
问题：给一个字符串数组，求两个字符串的乘积，并且这两个字符串没有公共字符
使用位运算来处理
解法：使用26个位来表示哪些字母出现，若两个字符串有重复，则他俩的与运算一定不为0



319. Bulb Switcher
初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭第二个。
第三轮，你每三个灯泡就切换第三个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换第 i 个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。
找出并返回 n 轮后有多少个亮着的灯泡

解：一个编号为 x 的灯泡经过 n 轮后处于打开状态的充要条件为「该灯泡被切换状态次数为奇数次」-> 求1--> n中有几个完全平方数，根据数论推理，有根号n个


320. Generalized Abbreviation
问题： 给定一个字符串，返回所有的字符串缩写

解法：使用dfs暴力遍历，每个字符有两种状态，压缩或者不压缩，总共有2**n个答案

322. Coin Change
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的

解法一：暴力递归：从0到amount递归，找出所有可能凑成amount的方法，找到最小值（超时）
解法二： 记忆化搜索： 从amount到0递归，对于已经计算过的amount保留其最小值，最终得出amount的最小值
解法三： 动态规划： 与记忆化搜索类似，不过用数组来处理，节省空间和时间



323. Number of Connected Components in an Undirected Graph
你有一个包含 n 个节点的图。给定一个整数 n 和一个数组 edges ，其中 edges[i] = [ai, bi] 表示图中 ai 和 bi 之间有一条边。
返回 图中已连接分量的数目。

解法：dfs bfs 并查集

dfs：先统计每个点的邻居点，设置一个visited数组，每次来到一个新的节点，如果未访问，count++，深度遍历与其所有相邻的节点（就是遍历该图上的所有节点）
（与岛屿数量问题基本一样）

324. Wiggle Sort II
给你一个整数数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。

你可以假设所有输入数组都可以得到满足题目要求的结果。

解法： 先将数组复制并排序，使用双指针，left指向克隆数组的中部，right指向末尾，遍历原数组，依次填充left、right



325. Maximum Size Subarray Sum Equals k
给定一个数组 nums 和一个目标值 k，找到和等于 k 的最长连续子数组长度。如果不存在任意一个符合要求的子数组，则返回 0。

解法：使用前缀和+哈希表处理，类似于求两数之和为target，这个为两数之差为target


328. Odd Even Linked List
问题：给定一个链表，将奇数位与偶数位拆分再合并，生成新链表

解：使用两个dummy，将分别将链表奇数位和偶数位串起来，分割奇偶之间的next


333. Largest BST Subtree
问题：经典树状dp问题，求BST的最大个数

解法：向左右子树要最大值和最小值，并且要size，通过size来判断是否为BST，如果不是，size = -1

331. Verify Preorder Serialization of a Binary Tree
问题：判断一个前序队列是否能组成二叉树

使用‘槽’这个概念来处理。初始槽为1，读取一个数字，槽-1+2，读取一个null，槽-1，最后判断槽是否为0，如果是，true


334. Increasing Triplet Subsequence
给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。
如果存在这样的三元组下标 (i, j, k) 且满足 i < j < k ，使得 nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 

解：1：遍历数组，分别求出i位置左侧最小和右侧最大，再遍历原数组判断左右大小
    2： 贪心算法，维护一个空间大小为2的数组，分别代表长度的1、2的序列的末尾数字，遍历数组，碰到比1、2小的就更新，如果出现比1、2大的，返回true
    3： 贪心： 维护两个变量first、second，其余同上


337. House Robber III
小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。
除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。
给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。

解：经典树状DP问题，但是在传递的过程中，要注意，如果父节点不偷，那么子节点可以偷也可以不偷，不一定是隔行投最划算


340. Longest Substring with At Most K Distinct Characters
给你一个字符串 s 和一个整数 k ，请你找出 至多 包含 k 个 不同 字符的最长子串，并返回该子串的长度

解法一：滑动窗口+哈希表，哈希表每次删除index最小的字母
解法二： 滑动窗口+有序哈希表（可以实现每次查找index最小的时间为O（1））


341. Flatten Nested List Iterator

解法一：将nestList展开
解法二：直接在原来的nestList中遍历迭代（方法更好，但是时间较长）


342. Power of Four
问题：判断一个数是否为4的幂

解法：这个数要大于0，并且其二进制表示中只能出现1个1，并且其mod 3 == 1



343. Integer Break
给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。
返回 你可以获得的最大乘积

解法：根据求导可得，n只能以2、3构成
最优： 3 。把数字 n 可能拆为多个因子 3 ，余数可能为 0,1,2 三种情况。
次优： 2 。若余数为 2 ；则保留，不再拆为 1+1 。
最差： 1 。若余数为 1 ；则应把一份 3 + 1 替换为 2 + 2，因为 2 * 2 > 3*1


347. Top K Frequent Elements
给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素

解：使用优先队列来解决
先遍历数组，并统计每个数字出现的次数，加入哈希表，用优先队列建立最小堆，将小于堆顶的元素放弃，大于堆顶的就抛弃堆顶并加入



355. Design Twitter

难点：合并k个有序序列
使用priorityQueue来处理


356. Line Reflection
在一个二维平面空间中，给你 n 个点的坐标。问，是否能找出一条平行于 y 轴的直线，让这些点关于这条直线成镜像排布？
注意：题目数据中可能有重复的点
解：使用排序+双指针
或者使用set来处理
重点：找出中轴线


357. Count Numbers with Unique Digits
给你一个整数 n ，统计并返回各位数字都不同的数字 x 的个数，其中 0 <= x < 10**n

想必大家都对高中数学知识忘得差不多了。这题可以用动态规划解：

n=0，数字有{0}1个。

n=1，数字有{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}10个。

n=2，数字包括两部分之和，一部分为n=1的所有10个答案，另一部分为长度为2的新增数字。长度为2的新增数字可以在n=1的所有9个数字基础上进行拼接（0不能算）。例如：

从n=1的数字列表{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}中随便取出一个除0以外的数字（因为0不能作为起始数字！），我们取2好了。通过在2的尾巴处拼接一位数字可以得到新的合法数字有：

{20， 21，23，24，25，26，27，28，29}，

可以看到，除了不能在尾巴处拼接一个2（两个连续的2就非法了！），0-9种一共有9个数字可以拿来拼接在尾巴处。新增答案为9个。同理，对于n=1数字列表{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}中的其他任意非0数也可以进行拼接操作，一共可以新增9*9个答案。

最终，n=2的合法数字，n=1时的答案 + 长度为2的数字个数（9*9个）= 10 + 81 = 91。

n=3时同理，只不过此时可以用拼接的数字减少为了8个，此时答案为10 + 9 * 9 + 9 * 9 * 8 = 739。

n=4时同理，只不过此时可以用拼接的数字减少为了7个，此时答案为10 + 9 * 9 + 9 * 9 * 8 + 9 * 9 * 8 * 7 = 5275。

通过归纳不难得到，假设 dp[i] 即 n = i时的答案，则动态转移方程为：

dp[i] = dp[i-1] + (dp[i-1] - dp[i-2])*(10-(i-1))

转移的初始条件为

dp[0] = 1

dp[1] = 10


361. Bomb Enemy
给你一个大小为 m x n 的矩阵 grid ，其中每个单元格都放置有一个字符：

'W' 表示一堵墙
'E' 表示一个敌人
'0'（数字 0）表示一个空位
返回你使用 一颗炸弹 可以击杀的最大敌人数目。你只能把炸弹放在一个空位里。

由于炸弹的威力不足以穿透墙体，炸弹只能击杀同一行和同一列没被墙体挡住的敌人

解法：
1.暴力破解，对于每个为‘0’ 的空格，遍历上下左右
2.dp 建立一个二维数组，统计每一个位置能找到的敌人，对一个位置，分别从左到右，从右到左，从上到下，从下到上四次扫描


362. Design Hit Counter
设计一个敲击计数器，使它可以统计在过去 5 分钟内被敲击次数。（即过去 300 秒）

您的系统应该接受一个时间戳参数 timestamp (单位为 秒 )，并且您可以假定对系统的调用是按时间顺序进行的(即 timestamp 是单调递增的)。几次撞击可能同时发生。

实现 HitCounter 类:

HitCounter() 初始化命中计数器系统。
void hit(int timestamp) 记录在 timestamp ( 单位为秒 )发生的一次命中。在同一个 timestamp 中可能会出现几个点击。
int getHits(int timestamp) 返回 timestamp 在过去 5 分钟内(即过去 300 秒)的命中次数

解法：
简单：用队列储存timestamp，用count来统计，每次要判断队列是否在新的timestamp-300之内，不是就弹出


364. Nested List Weight Sum II
返回一个列表的加权和  权重 = MaxDeep - deep + 1

解法一： dfs整个列表，获取maxDeep， 再dfs列表，求sum  两遍dfs
解法二： dfs整个列表，记录当前深度以及在该深度下的元素和，然后计算sum   一遍dfs


365. Water and Jug Problem
整数中的裴蜀定理
对任意两个整数a、b，设d是它们的最大公约数。那么关于未知数x和y的线性丢番图方程（称为 裴蜀等式 ）：
ax + by = m
有整数解（x,y）当且仅当m是d的倍数
最大公约数用辗转相除法求得


366. Find Leaves of Binary Tree
给你一棵二叉树，请按以下要求的顺序收集它的全部节点：

依次从左到右，每次收集并删除所有的叶子节点
重复如上过程直到整棵树为空

解： 其实就是对节点计算从叶子到根的深度，相同深度的组合一起



368. Largest Divisible Subset(最大整除数的集合)
给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足：
answer[i] % answer[j] == 0 ，或
answer[j] % answer[i] == 0
如果存在多个有效解子集，返回其中任何一个均可

解： sort + dp 


369. Plus One Linked List
给定一个用链表表示的非负整数， 然后将这个整数 再加上 1 。

这些数字的存储是这样的：最高位有效的数字位于链表的首位 head

解： 翻转链表再加1，注意要判断需不需要多加一个节点
或者 找到最后一位不为9的节点，将后面的都归0，该节点+1


370. Range Addition
假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，你将会被给出 k​​​​​​​ 个更新的操作。

其中，每个操作会被表示为一个三元组：[startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]（包括 startIndex 和 endIndex）增加 inc。

请你返回 k 次操作后的数组


解： 使用前缀和。 对于startIndex， + inc  对于endIndex+1， -inc。 就是处理数组，使其明白与前一个数的差值为多少，最后对整个数组求前缀和


371. Sum of Two Integers
不是用+ -来计算两数相加

解： 使用位运算来处理
用异或来求得两个数不产生进位是的答案
用与来求得哪一位产生进位，并且左移一位

372. Super Pow
你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出

解： (a⋅b) mod m=[(a mod m)⋅(b mod m)] mod m
利用底数a，对数组中的每一位b[i]进行计算取模，然后每次对a计算 a的10次幂取模


373. Find K Pairs with Smallest Sums
给定两个升序数组，找出k个和最小的对

解： 使用priorityQueue来处理。先将num1的所有和num2的第一个数组成的index对加入队列，每次取出一个，然后将num2的index+1的那一对加进来


375. Guess Number Higher or Lower II
我们正在玩一个猜数游戏，游戏规则如下：

我从 1 到 n 之间选择一个数字。
你来猜我选了哪个数字。
如果你猜到正确的数字，就会 赢得游戏 。
如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。
每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。
给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字

解： 类似于抽卡牌游戏，需要找到pick数字为x，1<=x<=n 时的最大代价，然后在所有的x中找到最小代价


376. Wiggle Subsequence
求一个数组中摆动排序最大长度

解： dp 借用两个参数up down， 分别表示末尾升序/降序的摆动排序的长度

377. Combination Sum IV
给定一个target 和一个数组nums，问用数组中的元素凑target，有几种凑法

解： dp    dfs（超时）


378. Kth Smallest Element in a Sorted Matrix
给定一个每行每列都升序的矩阵，求第k个数

解：1. 多路归并（考虑了每行升序） 2. 区域二分查找（考虑了每行每列升序）


380. Insert Delete GetRandom O(1)
在O(1)时间内实现 插入、删除、获取随机元素

解： 哈希表+不定长数组

382. Linked List Random Node
给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样

解： 数组模拟


383. Ransom Note
给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

如果可以，返回 true ；否则返回 false 。

magazine 中的每个字符只能在 ransomNote 中使用一次

解： 哈希表/ 数组模拟哈希表


384. Shuffle an Array
给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 等可能 的

解法： 洗牌算法， 对于每个下标i，将i与i之后的随机下标互换

386. Lexicographical Numbers
给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。

你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法

解： 能*10就*， 不能就/10,算好步数

387. First Unique Character in a String
给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1

解： 哈希表或数组模拟哈希表

389. Find the Difference
给定两个字符串 s 和 t ，它们只包含小写字母。

字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。

请找出在 t 中被添加的字母

解： 异或，数组模拟，哈希