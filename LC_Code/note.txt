306. Additive Number
一. 需要遍历判断第一个数和第二个数 -> 只需要判断第二个数的位置，第一个数一定是开头到第二个数之前，要判断如果开头为0，那么只能是0
二. 计算两个数的和，判断第三个数（从字符串中取出来）是否等于这两个数的和
是：将第二个数变为第一个数，第三个数变为第二个数，继续遍历，直到到达字符串结尾
否：跳出循环，在上一层继续遍历第二个数
三. 为了防止数字越界，使用字符串进行加法运算


307.Range Sum Query - Mutable

方法一：使用树状数组+前缀和
一. https://leetcode.cn/problems/range-sum-query-mutable/solution/-by-hu-ge-8-t4rn/
前缀和数组保存前缀和，s8 = n1+...+n8  s4 = n1+...n4  s2 = n1+n2  s1 = n1  s6 = n5+n6 利用位运算 j&(-j)获取j的最后一位1，
preSum(7) = s7(n7)+s6(n5+n6)+s4(n1+...n4)


309.Best Time to Buy and Sell Stock with Cooldown
需要考虑三种情况：
一. 当前持有股票，那么当前的状态有两种可能，之前持有股票，或者之前处于冷冻期结束
二. 当前不持有股票，且当前在冷冻期。那么说明前一天持有股票并卖出了
三. 当前不持有股票，且不在冷冻期。那么说明前一天在冷冻期，或者前一天也不持有股票且不在冷冻期


310.Minimum Height Trees
基于拓扑排序以及bfs来处理
先根据二维数组建立入度表，因为这里是无向边，所以不用区分入度与出度
将所有度数为一的点进入队列，分别弹出这些点，并且根据哈希表变更与其相连的其他点的入度，将变更后度数为1的点加入队列
最后的答案为最后一批加入队列的点


313.Super Ugly Number
使用动态规划和多指针来处理
建立多指针数组pointers，建立乘积数组nums来储存乘积。
遍历nums，找到最小值，放入dp中，并使得对应的pointer+1，更新nums（注意，因为要使得nums都为Ugly Number，所以不能直接用pointer * primes，
要利用dp找到当前的pointer所对应的值，然后再乘nums）


314.Binary Tree Vertical Order Traversal
使用bfs来处理
在将节点加入队列时，应该同时保存节点的列位置
TreeMap可以自动维护key从小到大

316. Remove Duplicate Letters
问题：给定一个字符串，返回一个字典序最小的字符串，并且字符串中每个字母出现一次

使用单调栈来进行处理
解法一：
统计原串中每个字母出现的次数
遍历字符串，对每个字符判断是否小于栈顶元素，如果是并且栈顶元素在之后还存在，弹出栈顶，重复以上操作，最后将该字符入栈，更新次数

解法二：(faster , use array)
统计原串中每个字母出现的最后位置
其余同上


318. Maximum Product of Word Lengths
问题：给一个字符串数组，求两个字符串的乘积，并且这两个字符串没有公共字符
使用位运算来处理
解法：使用26个位来表示哪些字母出现，若两个字符串有重复，则他俩的与运算一定不为0



319. Bulb Switcher
初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭第二个。
第三轮，你每三个灯泡就切换第三个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换第 i 个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。
找出并返回 n 轮后有多少个亮着的灯泡

解：一个编号为 x 的灯泡经过 n 轮后处于打开状态的充要条件为「该灯泡被切换状态次数为奇数次」-> 求1--> n中有几个完全平方数，根据数论推理，有根号n个


320. Generalized Abbreviation
问题： 给定一个字符串，返回所有的字符串缩写

解法：使用dfs暴力遍历，每个字符有两种状态，压缩或者不压缩，总共有2**n个答案

322. Coin Change
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的

解法一：暴力递归：从0到amount递归，找出所有可能凑成amount的方法，找到最小值（超时）
解法二： 记忆化搜索： 从amount到0递归，对于已经计算过的amount保留其最小值，最终得出amount的最小值
解法三： 动态规划： 与记忆化搜索类似，不过用数组来处理，节省空间和时间



323. Number of Connected Components in an Undirected Graph
你有一个包含 n 个节点的图。给定一个整数 n 和一个数组 edges ，其中 edges[i] = [ai, bi] 表示图中 ai 和 bi 之间有一条边。
返回 图中已连接分量的数目。

解法：dfs bfs 并查集

dfs：先统计每个点的邻居点，设置一个visited数组，每次来到一个新的节点，如果未访问，count++，深度遍历与其所有相邻的节点（就是遍历该图上的所有节点）
（与岛屿数量问题基本一样）

324. Wiggle Sort II
给你一个整数数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。

你可以假设所有输入数组都可以得到满足题目要求的结果。

解法： 先将数组复制并排序，使用双指针，left指向克隆数组的中部，right指向末尾，遍历原数组，依次填充left、right



325. Maximum Size Subarray Sum Equals k
给定一个数组 nums 和一个目标值 k，找到和等于 k 的最长连续子数组长度。如果不存在任意一个符合要求的子数组，则返回 0。

解法：使用前缀和+哈希表处理，类似于求两数之和为target，这个为两数之差为target


328. Odd Even Linked List
问题：给定一个链表，将奇数位与偶数位拆分再合并，生成新链表

解：使用两个dummy，将分别将链表奇数位和偶数位串起来，分割奇偶之间的next


333. Largest BST Subtree
问题：经典树状dp问题，求BST的最大个数

解法：向左右子树要最大值和最小值，并且要size，通过size来判断是否为BST，如果不是，size = -1

331. Verify Preorder Serialization of a Binary Tree
问题：判断一个前序队列是否能组成二叉树

使用‘槽’这个概念来处理。初始槽为1，读取一个数字，槽-1+2，读取一个null，槽-1，最后判断槽是否为0，如果是，true


334. Increasing Triplet Subsequence
给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。
如果存在这样的三元组下标 (i, j, k) 且满足 i < j < k ，使得 nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 

解：1：遍历数组，分别求出i位置左侧最小和右侧最大，再遍历原数组判断左右大小
    2： 贪心算法，维护一个空间大小为2的数组，分别代表长度的1、2的序列的末尾数字，遍历数组，碰到比1、2小的就更新，如果出现比1、2大的，返回true
    3： 贪心： 维护两个变量first、second，其余同上


337. House Robber III
小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。
除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。
给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。

解：经典树状DP问题，但是在传递的过程中，要注意，如果父节点不偷，那么子节点可以偷也可以不偷，不一定是隔行投最划算


340. Longest Substring with At Most K Distinct Characters
给你一个字符串 s 和一个整数 k ，请你找出 至多 包含 k 个 不同 字符的最长子串，并返回该子串的长度

解法一：滑动窗口+哈希表，哈希表每次删除index最小的字母
解法二： 滑动窗口+有序哈希表（可以实现每次查找index最小的时间为O（1））


341. Flatten Nested List Iterator

解法一：将nestList展开
解法二：直接在原来的nestList中遍历迭代（方法更好，但是时间较长）


342. Power of Four
问题：判断一个数是否为4的幂

解法：这个数要大于0，并且其二进制表示中只能出现1个1，并且其mod 3 == 1



343. Integer Break
给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。
返回 你可以获得的最大乘积

解法：根据求导可得，n只能以2、3构成
最优： 3 。把数字 n 可能拆为多个因子 3 ，余数可能为 0,1,2 三种情况。
次优： 2 。若余数为 2 ；则保留，不再拆为 1+1 。
最差： 1 。若余数为 1 ；则应把一份 3 + 1 替换为 2 + 2，因为 2 * 2 > 3*1


347. Top K Frequent Elements
给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素

解：使用优先队列来解决
先遍历数组，并统计每个数字出现的次数，加入哈希表，用优先队列建立最小堆，将小于堆顶的元素放弃，大于堆顶的就抛弃堆顶并加入


