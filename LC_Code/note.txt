306. Additive Number
一. 需要遍历判断第一个数和第二个数 -> 只需要判断第二个数的位置，第一个数一定是开头到第二个数之前，要判断如果开头为0，那么只能是0
二. 计算两个数的和，判断第三个数（从字符串中取出来）是否等于这两个数的和
是：将第二个数变为第一个数，第三个数变为第二个数，继续遍历，直到到达字符串结尾
否：跳出循环，在上一层继续遍历第二个数
三. 为了防止数字越界，使用字符串进行加法运算


307.Range Sum Query - Mutable

方法一：使用树状数组+前缀和
一. https://leetcode.cn/problems/range-sum-query-mutable/solution/-by-hu-ge-8-t4rn/
前缀和数组保存前缀和，s8 = n1+...+n8  s4 = n1+...n4  s2 = n1+n2  s1 = n1  s6 = n5+n6 利用位运算 j&(-j)获取j的最后一位1，
preSum(7) = s7(n7)+s6(n5+n6)+s4(n1+...n4)


309.Best Time to Buy and Sell Stock with Cooldown
需要考虑三种情况：
一. 当前持有股票，那么当前的状态有两种可能，之前持有股票，或者之前处于冷冻期结束
二. 当前不持有股票，且当前在冷冻期。那么说明前一天持有股票并卖出了
三. 当前不持有股票，且不在冷冻期。那么说明前一天在冷冻期，或者前一天也不持有股票且不在冷冻期


310.Minimum Height Trees
基于拓扑排序以及bfs来处理
先根据二维数组建立入度表，因为这里是无向边，所以不用区分入度与出度
将所有度数为一的点进入队列，分别弹出这些点，并且根据哈希表变更与其相连的其他点的入度，将变更后度数为1的点加入队列
最后的答案为最后一批加入队列的点


313.Super Ugly Number
使用动态规划和多指针来处理
建立多指针数组pointers，建立乘积数组nums来储存乘积。
遍历nums，找到最小值，放入dp中，并使得对应的pointer+1，更新nums（注意，因为要使得nums都为Ugly Number，所以不能直接用pointer * primes，
要利用dp找到当前的pointer所对应的值，然后再乘nums）


314.Binary Tree Vertical Order Traversal
使用bfs来处理
在将节点加入队列时，应该同时保存节点的列位置
TreeMap可以自动维护key从小到大

316. Remove Duplicate Letters
问题：给定一个字符串，返回一个字典序最小的字符串，并且字符串中每个字母出现一次

使用单调栈来进行处理
解法一：
统计原串中每个字母出现的次数
遍历字符串，对每个字符判断是否小于栈顶元素，如果是并且栈顶元素在之后还存在，弹出栈顶，重复以上操作，最后将该字符入栈，更新次数

解法二：(faster , use array)
统计原串中每个字母出现的最后位置
其余同上


318. Maximum Product of Word Lengths
问题：给一个字符串数组，求两个字符串的乘积，并且这两个字符串没有公共字符
使用位运算来处理
解法：使用26个位来表示哪些字母出现，若两个字符串有重复，则他俩的与运算一定不为0



319. Bulb Switcher
初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭第二个。
第三轮，你每三个灯泡就切换第三个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换第 i 个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。
找出并返回 n 轮后有多少个亮着的灯泡

解：一个编号为 x 的灯泡经过 n 轮后处于打开状态的充要条件为「该灯泡被切换状态次数为奇数次」-> 求1--> n中有几个完全平方数，根据数论推理，有根号n个


320. Generalized Abbreviation
问题： 给定一个字符串，返回所有的字符串缩写

解法：使用dfs暴力遍历，每个字符有两种状态，压缩或者不压缩，总共有2**n个答案

322. Coin Change
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的

解法一：暴力递归：从0到amount递归，找出所有可能凑成amount的方法，找到最小值（超时）
解法二： 记忆化搜索： 从amount到0递归，对于已经计算过的amount保留其最小值，最终得出amount的最小值
解法三： 动态规划： 与记忆化搜索类似，不过用数组来处理，节省空间和时间



323. Number of Connected Components in an Undirected Graph
你有一个包含 n 个节点的图。给定一个整数 n 和一个数组 edges ，其中 edges[i] = [ai, bi] 表示图中 ai 和 bi 之间有一条边。
返回 图中已连接分量的数目。

解法：dfs bfs 并查集

dfs：先统计每个点的邻居点，设置一个visited数组，每次来到一个新的节点，如果未访问，count++，深度遍历与其所有相邻的节点（就是遍历该图上的所有节点）
（与岛屿数量问题基本一样）

324. Wiggle Sort II
给你一个整数数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。

你可以假设所有输入数组都可以得到满足题目要求的结果。

解法： 先将数组复制并排序，使用双指针，left指向克隆数组的中部，right指向末尾，遍历原数组，依次填充left、right



325. Maximum Size Subarray Sum Equals k
给定一个数组 nums 和一个目标值 k，找到和等于 k 的最长连续子数组长度。如果不存在任意一个符合要求的子数组，则返回 0。

解法：使用前缀和+哈希表处理，类似于求两数之和为target，这个为两数之差为target


328. Odd Even Linked List
问题：给定一个链表，将奇数位与偶数位拆分再合并，生成新链表

解：使用两个dummy，将分别将链表奇数位和偶数位串起来，分割奇偶之间的next


333. Largest BST Subtree
问题：经典树状dp问题，求BST的最大个数

解法：向左右子树要最大值和最小值，并且要size，通过size来判断是否为BST，如果不是，size = -1

331. Verify Preorder Serialization of a Binary Tree
问题：判断一个前序队列是否能组成二叉树

使用‘槽’这个概念来处理。初始槽为1，读取一个数字，槽-1+2，读取一个null，槽-1，最后判断槽是否为0，如果是，true


334. Increasing Triplet Subsequence
给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。
如果存在这样的三元组下标 (i, j, k) 且满足 i < j < k ，使得 nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 

解：1：遍历数组，分别求出i位置左侧最小和右侧最大，再遍历原数组判断左右大小
    2： 贪心算法，维护一个空间大小为2的数组，分别代表长度的1、2的序列的末尾数字，遍历数组，碰到比1、2小的就更新，如果出现比1、2大的，返回true
    3： 贪心： 维护两个变量first、second，其余同上


337. House Robber III
小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。
除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。
给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。

解：经典树状DP问题，但是在传递的过程中，要注意，如果父节点不偷，那么子节点可以偷也可以不偷，不一定是隔行投最划算


340. Longest Substring with At Most K Distinct Characters
给你一个字符串 s 和一个整数 k ，请你找出 至多 包含 k 个 不同 字符的最长子串，并返回该子串的长度

解法一：滑动窗口+哈希表，哈希表每次删除index最小的字母
解法二： 滑动窗口+有序哈希表（可以实现每次查找index最小的时间为O（1））


341. Flatten Nested List Iterator

解法一：将nestList展开
解法二：直接在原来的nestList中遍历迭代（方法更好，但是时间较长）


342. Power of Four
问题：判断一个数是否为4的幂

解法：这个数要大于0，并且其二进制表示中只能出现1个1，并且其mod 3 == 1



343. Integer Break
给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。
返回 你可以获得的最大乘积

解法：根据求导可得，n只能以2、3构成
最优： 3 。把数字 n 可能拆为多个因子 3 ，余数可能为 0,1,2 三种情况。
次优： 2 。若余数为 2 ；则保留，不再拆为 1+1 。
最差： 1 。若余数为 1 ；则应把一份 3 + 1 替换为 2 + 2，因为 2 * 2 > 3*1


347. Top K Frequent Elements
给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素

解：使用优先队列来解决
先遍历数组，并统计每个数字出现的次数，加入哈希表，用优先队列建立最小堆，将小于堆顶的元素放弃，大于堆顶的就抛弃堆顶并加入



355. Design Twitter

难点：合并k个有序序列
使用priorityQueue来处理


356. Line Reflection
在一个二维平面空间中，给你 n 个点的坐标。问，是否能找出一条平行于 y 轴的直线，让这些点关于这条直线成镜像排布？
注意：题目数据中可能有重复的点
解：使用排序+双指针
或者使用set来处理
重点：找出中轴线


357. Count Numbers with Unique Digits
给你一个整数 n ，统计并返回各位数字都不同的数字 x 的个数，其中 0 <= x < 10**n

想必大家都对高中数学知识忘得差不多了。这题可以用动态规划解：

n=0，数字有{0}1个。

n=1，数字有{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}10个。

n=2，数字包括两部分之和，一部分为n=1的所有10个答案，另一部分为长度为2的新增数字。长度为2的新增数字可以在n=1的所有9个数字基础上进行拼接（0不能算）。例如：

从n=1的数字列表{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}中随便取出一个除0以外的数字（因为0不能作为起始数字！），我们取2好了。通过在2的尾巴处拼接一位数字可以得到新的合法数字有：

{20， 21，23，24，25，26，27，28，29}，

可以看到，除了不能在尾巴处拼接一个2（两个连续的2就非法了！），0-9种一共有9个数字可以拿来拼接在尾巴处。新增答案为9个。同理，对于n=1数字列表{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}中的其他任意非0数也可以进行拼接操作，一共可以新增9*9个答案。

最终，n=2的合法数字，n=1时的答案 + 长度为2的数字个数（9*9个）= 10 + 81 = 91。

n=3时同理，只不过此时可以用拼接的数字减少为了8个，此时答案为10 + 9 * 9 + 9 * 9 * 8 = 739。

n=4时同理，只不过此时可以用拼接的数字减少为了7个，此时答案为10 + 9 * 9 + 9 * 9 * 8 + 9 * 9 * 8 * 7 = 5275。

通过归纳不难得到，假设 dp[i] 即 n = i时的答案，则动态转移方程为：

dp[i] = dp[i-1] + (dp[i-1] - dp[i-2])*(10-(i-1))

转移的初始条件为

dp[0] = 1

dp[1] = 10


361. Bomb Enemy
给你一个大小为 m x n 的矩阵 grid ，其中每个单元格都放置有一个字符：

'W' 表示一堵墙
'E' 表示一个敌人
'0'（数字 0）表示一个空位
返回你使用 一颗炸弹 可以击杀的最大敌人数目。你只能把炸弹放在一个空位里。

由于炸弹的威力不足以穿透墙体，炸弹只能击杀同一行和同一列没被墙体挡住的敌人

解法：
1.暴力破解，对于每个为‘0’ 的空格，遍历上下左右
2.dp 建立一个二维数组，统计每一个位置能找到的敌人，对一个位置，分别从左到右，从右到左，从上到下，从下到上四次扫描


362. Design Hit Counter
设计一个敲击计数器，使它可以统计在过去 5 分钟内被敲击次数。（即过去 300 秒）

您的系统应该接受一个时间戳参数 timestamp (单位为 秒 )，并且您可以假定对系统的调用是按时间顺序进行的(即 timestamp 是单调递增的)。几次撞击可能同时发生。

实现 HitCounter 类:

HitCounter() 初始化命中计数器系统。
void hit(int timestamp) 记录在 timestamp ( 单位为秒 )发生的一次命中。在同一个 timestamp 中可能会出现几个点击。
int getHits(int timestamp) 返回 timestamp 在过去 5 分钟内(即过去 300 秒)的命中次数

解法：
简单：用队列储存timestamp，用count来统计，每次要判断队列是否在新的timestamp-300之内，不是就弹出


364. Nested List Weight Sum II
返回一个列表的加权和  权重 = MaxDeep - deep + 1

解法一： dfs整个列表，获取maxDeep， 再dfs列表，求sum  两遍dfs
解法二： dfs整个列表，记录当前深度以及在该深度下的元素和，然后计算sum   一遍dfs


365. Water and Jug Problem
整数中的裴蜀定理
对任意两个整数a、b，设d是它们的最大公约数。那么关于未知数x和y的线性丢番图方程（称为 裴蜀等式 ）：
ax + by = m
有整数解（x,y）当且仅当m是d的倍数
最大公约数用辗转相除法求得


366. Find Leaves of Binary Tree
给你一棵二叉树，请按以下要求的顺序收集它的全部节点：

依次从左到右，每次收集并删除所有的叶子节点
重复如上过程直到整棵树为空

解： 其实就是对节点计算从叶子到根的深度，相同深度的组合一起



368. Largest Divisible Subset(最大整除数的集合)
给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer ，子集中每一元素对 (answer[i], answer[j]) 都应当满足：
answer[i] % answer[j] == 0 ，或
answer[j] % answer[i] == 0
如果存在多个有效解子集，返回其中任何一个均可

解： sort + dp 


369. Plus One Linked List
给定一个用链表表示的非负整数， 然后将这个整数 再加上 1 。

这些数字的存储是这样的：最高位有效的数字位于链表的首位 head

解： 翻转链表再加1，注意要判断需不需要多加一个节点
或者 找到最后一位不为9的节点，将后面的都归0，该节点+1


370. Range Addition
假设你有一个长度为 n 的数组，初始情况下所有的数字均为 0，你将会被给出 k​​​​​​​ 个更新的操作。

其中，每个操作会被表示为一个三元组：[startIndex, endIndex, inc]，你需要将子数组 A[startIndex ... endIndex]（包括 startIndex 和 endIndex）增加 inc。

请你返回 k 次操作后的数组


解： 使用前缀和。 对于startIndex， + inc  对于endIndex+1， -inc。 就是处理数组，使其明白与前一个数的差值为多少，最后对整个数组求前缀和


371. Sum of Two Integers
不是用+ -来计算两数相加

解： 使用位运算来处理
用异或来求得两个数不产生进位是的答案
用与来求得哪一位产生进位，并且左移一位

372. Super Pow
你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出

解： (a⋅b) mod m=[(a mod m)⋅(b mod m)] mod m
利用底数a，对数组中的每一位b[i]进行计算取模，然后每次对a计算 a的10次幂取模


373. Find K Pairs with Smallest Sums
给定两个升序数组，找出k个和最小的对

解： 使用priorityQueue来处理。先将num1的所有和num2的第一个数组成的index对加入队列，每次取出一个，然后将num2的index+1的那一对加进来


375. Guess Number Higher or Lower II
我们正在玩一个猜数游戏，游戏规则如下：

我从 1 到 n 之间选择一个数字。
你来猜我选了哪个数字。
如果你猜到正确的数字，就会 赢得游戏 。
如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。
每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。
给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字

解： 类似于抽卡牌游戏，需要找到pick数字为x，1<=x<=n 时的最大代价，然后在所有的x中找到最小代价


376. Wiggle Subsequence
求一个数组中摆动排序最大长度

解： dp 借用两个参数up down， 分别表示末尾升序/降序的摆动排序的长度

377. Combination Sum IV
给定一个target 和一个数组nums，问用数组中的元素凑target，有几种凑法

解： dp    dfs（超时）


378. Kth Smallest Element in a Sorted Matrix
给定一个每行每列都升序的矩阵，求第k个数

解：1. 多路归并（考虑了每行升序） 2. 区域二分查找（考虑了每行每列升序）