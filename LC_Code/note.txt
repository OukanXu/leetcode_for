306. Additive Number
一. 需要遍历判断第一个数和第二个数 -> 只需要判断第二个数的位置，第一个数一定是开头到第二个数之前，要判断如果开头为0，那么只能是0
二. 计算两个数的和，判断第三个数（从字符串中取出来）是否等于这两个数的和
是：将第二个数变为第一个数，第三个数变为第二个数，继续遍历，直到到达字符串结尾
否：跳出循环，在上一层继续遍历第二个数
三. 为了防止数字越界，使用字符串进行加法运算


307.Range Sum Query - Mutable

方法一：使用树状数组+前缀和
一. https://leetcode.cn/problems/range-sum-query-mutable/solution/-by-hu-ge-8-t4rn/
前缀和数组保存前缀和，s8 = n1+...+n8  s4 = n1+...n4  s2 = n1+n2  s1 = n1  s6 = n5+n6 利用位运算 j&(-j)获取j的最后一位1，
preSum(7) = s7(n7)+s6(n5+n6)+s4(n1+...n4)


309.Best Time to Buy and Sell Stock with Cooldown
需要考虑三种情况：
一. 当前持有股票，那么当前的状态有两种可能，之前持有股票，或者之前处于冷冻期结束
二. 当前不持有股票，且当前在冷冻期。那么说明前一天持有股票并卖出了
三. 当前不持有股票，且不在冷冻期。那么说明前一天在冷冻期，或者前一天也不持有股票且不在冷冻期


310.Minimum Height Trees
基于拓扑排序以及bfs来处理
先根据二维数组建立入度表，因为这里是无向边，所以不用区分入度与出度
将所有度数为一的点进入队列，分别弹出这些点，并且根据哈希表变更与其相连的其他点的入度，将变更后度数为1的点加入队列
最后的答案为最后一批加入队列的点


313.Super Ugly Number
使用动态规划和多指针来处理
建立多指针数组pointers，建立乘积数组nums来储存乘积。
遍历nums，找到最小值，放入dp中，并使得对应的pointer+1，更新nums（注意，因为要使得nums都为Ugly Number，所以不能直接用pointer * primes，
要利用dp找到当前的pointer所对应的值，然后再乘nums）


314.Binary Tree Vertical Order Traversal
使用bfs来处理
在将节点加入队列时，应该同时保存节点的列位置
TreeMap可以自动维护key从小到大

316. Remove Duplicate Letters
问题：给定一个字符串，返回一个字典序最小的字符串，并且字符串中每个字母出现一次

使用单调栈来进行处理
解法一：
统计原串中每个字母出现的次数
遍历字符串，对每个字符判断是否小于栈顶元素，如果是并且栈顶元素在之后还存在，弹出栈顶，重复以上操作，最后将该字符入栈，更新次数

解法二：(faster , use array)
统计原串中每个字母出现的最后位置
其余同上


318. Maximum Product of Word Lengths
问题：给一个字符串数组，求两个字符串的乘积，并且这两个字符串没有公共字符
使用位运算来处理
解法：使用26个位来表示哪些字母出现，若两个字符串有重复，则他俩的与运算一定不为0