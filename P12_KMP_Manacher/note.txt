KMP：Code01
1.字符串str1和str2，str1是否包含str2，如果包含，返回str2在str1中的位置  要求：时间O（N）
前缀长度和后缀长度：
从某个字符开始，前缀为字符串头开始到该字符，后缀为该字符开始往前到字符串头
设一个字符串  abbabbK

对于字符K，当前后缀长度为1是，前后缀分别为a，b，不相等；当前后缀长度为2是，前后缀分别为ab，bb，不相等；当前后缀长度为3是，前后缀分别为abb，abb。。。
不考虑前缀和后缀都为K前所有字符的情况，所以K的记录为3，意义为K最大的前后缀相当长度

对str2求其最大前后缀相当的数，放入nextarr中，对于第一个字符，因为没有前字符串，所以人为规定-1，第二个字符前只有一个字符，因为不能取全部，人为规定0；
所以求得任意一个str2的字符，其前后缀最大的相等值

算法过程：
设str1 = [i,...x]
str2 = [O,...Y]
如果str1和str2除最后一位外全都相等，（按照经典算法，应该开始比对i+1，即str1回到i+1开始，str2回到O+1开始重新比对），在KMP中，str1指针停留在x位置不变
str2指针回调到该位置的最大前后缀的前半部分的后一位开始重新比对
str1 = "abbstk sc abbstk（1） s..."
str2 = "abbstk（2） sc abbstk Z"
因此，str2从第二个s开始比对，因为我知道1和2一定相等，所以1、2不比较，从1、2之后开始继续比较






Manacher:
1.字符串str中，最长回文子串的长度 时间O（N）

回文半径和回文直径 #a#1#2#1#b#
对于2来说，回文直径为7，半径为4

之前所扩的所有位置中，所到达的最右回文右边界 int R = -1;记录有没有把右边界扩到更远的位置
int C；取得更远边界时，中心点所在的位置，R和C同时更新

1）当来到某个中心点时，这个点没在R里面，暴力扩，看能扩多远，更新R和C
2）当来到某个中心点i时，这个点在R里面，已知中心点C，已知右边界R，已知左边界R，根据C求得i的对称i'
.1 当i'的回文在L-R范围内，i的情况和i'相同
.2 当i'的回文有一部分在L-R范围之外，此时i的半径答案为 i-R这一段
.3 当i'的回文与L重叠，此情况i-R不需要验证，必定回文，但是需要向R+1扩充，判断是否回文



