前缀树： Code01
一个字符串类型的数组arr1，另一个字符串类型的数组arr2.
1.arr2中有哪些字符，是arr1中出现的？ 打印
2.arr2中有哪些字符，是作为arr1中某个字符串前缀出现的？打印
3.arr2中有哪些字符，是作为arr1中某个字符串前缀出现的？打印arr2中出现次数最大的前缀

建立树，字符在路上，不在节点上




贪心算法：
在某个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的算法
也就是说，不从整体最优上考虑，所做出的是在某种意义上的局部最优解

局部最优 -?-> 整体最优

贪心策略常用堆和排序

贪心算法笔试时思路：
1.实现一个不依靠贪心算法的解法X，可以用最暴力的
2.脑补贪心策略A、B、C
3.用解法X和对数器，去验证每个贪心策略
4.不要纠结贪心策略的证明

1.会议问题  Code04
一些项目要占用一个会议室，会议室不能同时容纳两个项目，给你每一个项目开始的时间和结束的时间（给你一个数组，里面是具体的项目），
你来安排会议日程，要求会议进行的项目次数最多，返回最多的次数

解法：先结束的会议先安排


2.字符串拼接问题  Code02
给定一个字符串数组，要求拼接后的字符串字典序最小

解法：将字符串数组排序，排序方法为 设a、b两个字符串，如果a+b的字典序小于b+a的字典序，a b，否则b a 


3.分割金条问题 Code03
一块金条切成两半，需要花费和长度相同的铜板。
一群人分割金条，问怎么最省铜板
例如，给定数组[10,20,30]，代表三个人需要的金条，给定整块金条长度为10+20+30=60，金条要分成10,20,30三部分。
如果先分成10+50，再把50分成20+30，需要60+50 = 110铜板
如果先分成30+30，再把30分成10+20，需要60+30 = 90铜板
输入一个数组，返回分割的最小代价

解法：建议一个小根堆，每次弹出两个数相加，sum += 这两数之和，将和压入堆，直到堆最后为1，返回sum


4.项目最大收益问题 Code05
输入：
正数数组costs
正数数组profits
正数k
正数m
含义：
costs[i]表示项目i的花费
profits[i]表示i号项目扣除花费之后的收益
k表示你只能串行做k个项目
m表示你的初始资金
说明：
你每做完一个项目，马上获得收益，收益用来做下个项目
输出：
最后获得的最大剩余收益

解法：建立一个小根堆，按照costs顺序排，比较m，将costs小于m的弹出，加入到一个大根堆中，大根堆按照profits排序，
每次弹出大根堆堆顶，更新m，继续比对小根堆，直到完成项目数量到达k。



额外（非贪心）：给一个数据流，随时求中位数

解法：建立一个大根堆和小根堆
1）当前数字 <= 大根堆堆顶 ？= true
2）true：入大根堆，false：入小根堆
3）建立size1和size2表示两个堆中数字个数，如果大的size - 小的size == 2， 大的size的堆顶弹出加入小的size的堆

n/2 个数在大根堆，n/2 个数在小根堆，根据堆顶就可以求中位数